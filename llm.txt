# Magi 3D SDK - LLM Context File

> Universal TypeScript SDK for 3D generative AI providers. Generate 3D models from text or images using a unified API.

This file serves two audiences:
- **SDK Users**: Developers integrating Magi 3D into their applications
- **SDK Contributors**: Developers contributing to the SDK itself

---

# PART 1: FOR SDK USERS

## Quick Start

```typescript
import { Magi3DClient, TripoProvider, TaskType } from 'magi-3d/server';

const provider = new TripoProvider(); // Uses TRIPO_API_KEY env var
const client = new Magi3DClient(provider);

// Generate 3D model from text
const taskId = await client.createTask({
  type: TaskType.TEXT_TO_3D,
  prompt: 'a cute cat'
});

// Wait for completion
const result = await client.pollUntilDone(taskId);
console.log('Model URL:', result.result?.model); // Primary model URL
console.log('Raw Response:', result.rawResponse); // Provider's raw API response
```

## Installation

```bash
npm install magi-3d
# or
pnpm add magi-3d
```

## Entry Points

```
magi-3d           → Main exports (types, enums)
magi-3d/server    → Server-side (providers, client) - USE THIS FOR BACKEND
magi-3d/react     → React hooks (useCreateTask, useTaskStatus) - USE THIS FOR FRONTEND
```

## Provider Setup

### Tripo

```typescript
import { TripoProvider } from 'magi-3d/server';

// Option 1: Use environment variable (recommended)
const provider = new TripoProvider(); // Uses process.env.TRIPO_API_KEY

// Option 2: Explicit API key
const provider = new TripoProvider({
  apiKey: 'your-api-key'
});

// Option 3: Enable STS upload (allows local file paths, localhost URLs, base64)
const provider = new TripoProvider({
  apiKey: 'your-api-key',
  stsUpload: true
});
```

### Hunyuan (Tencent Cloud)

```typescript
import { HunyuanProvider } from 'magi-3d/server';

// Option 1: Use environment variables (recommended)
const provider = new HunyuanProvider({
  region: 'ap-guangzhou'
}); // Uses HUNYUAN_SECRET_ID and HUNYUAN_SECRET_KEY

// Option 2: Explicit credentials
const provider = new HunyuanProvider({
  secretId: 'your-secret-id',
  secretKey: 'your-secret-key',
  region: 'ap-guangzhou'
});
```

## TaskType Reference

All 18 task types with provider support:

| Type | Description | Required Params | Tripo | Hunyuan |
|------|-------------|-----------------|-------|---------|
| `TEXT_TO_3D` | Generate 3D from text | `prompt` | Yes | Yes |
| `IMAGE_TO_3D` | Generate 3D from image | `input` | Yes | Yes |
| `MULTIVIEW_TO_3D` | Generate 3D from multi views | `inputs[]` | Yes | Yes |
| `TEXT_TO_IMAGE` | Generate image from text | `prompt` | Yes | No |
| `GENERATE_IMAGE` | Advanced image generation | `prompt` | Yes | No |
| `TEXTURE` | Re-texture model | `taskId` or `modelUrl` | Yes | Yes |
| `REFINE` | Improve model quality | `taskId` | Yes | No |
| `PRE_RIG_CHECK` | Check if model is riggable | `taskId` | Yes | No |
| `RIG` | Add skeleton rigging | `taskId` | Yes | No |
| `ANIMATE` | Apply animation to rigged model | `taskId`, `animation` | Yes | No |
| `SEGMENT` | Split model into parts | `taskId` or `modelUrl` | Yes | Yes (FBX only) |
| `MESH_COMPLETION` | Complete/fill mesh parts | `taskId`, `partNames?` | Yes | No |
| `DECIMATE` | Reduce polygon count | `taskId` or `modelUrl` | Yes | Yes |
| `UV_UNWRAP` | UV unwrap model | `modelUrl` | No | Yes |
| `PROFILE_TO_3D` | Face photo to 3D character | `input`, `template` | No | Yes |
| `CONVERT` | Format conversion | `taskId`, `format` | Yes | Yes |
| `IMPORT` | Import external 3D model | `input` | Yes | No |
| `STYLIZE` | Apply artistic style | `taskId`, `style` | Yes | No |

> **Note:** Hunyuan post-processing tasks (TEXTURE, DECIMATE, SEGMENT, UV_UNWRAP) require `modelUrl` instead of `taskId`. Tripo post-processing tasks use `taskId` to chain from a previous task.
>
> **Hunyuan SEGMENT constraint:** The Segment (3D Part Generation) API only accepts FBX format files. If chaining from a text-to-3d or image-to-3d result (which outputs GLB), you must convert to FBX first using `TaskType.CONVERT` with `format: 'fbx'`.

## Common Use Cases

### 1. Text-to-3D Generation

```typescript
const taskId = await client.createTask({
  type: TaskType.TEXT_TO_3D,
  prompt: 'a medieval castle with towers',
  providerOptions: {
    pbr: true,
    texture_quality: 'detailed'
  }
});
```

### 2. Image-to-3D Generation

```typescript
const taskId = await client.createTask({
  type: TaskType.IMAGE_TO_3D,
  input: 'https://example.com/product-photo.jpg'
});
```

### 3. Image-to-3D with Local File (Tripo STS Upload)

```typescript
// Enable stsUpload in provider config
const provider = new TripoProvider({ stsUpload: true });
const client = new Magi3DClient(provider);

// Now you can pass local file paths, localhost URLs, or base64
const taskId = await client.createTask({
  type: TaskType.IMAGE_TO_3D,
  input: '/path/to/local/image.jpg'           // Local file path
  // or: 'http://localhost:3000/image.jpg'     // Localhost URL
  // or: 'data:image/png;base64,iVBORw0K...'   // Base64
});
```

### 4. Multi-view to 3D

```typescript
// Tripo: 4 views [front, left, back, right]
const taskId = await client.createTask({
  type: TaskType.MULTIVIEW_TO_3D,
  inputs: [
    'https://example.com/front.jpg',
    'https://example.com/left.jpg',
    'https://example.com/back.jpg',
    'https://example.com/right.jpg'
  ]
});

// Hunyuan: front image + optional additional views (left, back, right)
// Uses the same inputs[] array - front is required, others are optional
const taskId = await client.createTask({
  type: TaskType.MULTIVIEW_TO_3D,
  inputs: [
    'https://example.com/front.jpg',
    'https://example.com/left.jpg',
    'https://example.com/back.jpg',
    'https://example.com/right.jpg'
  ]
});
```

### 5. Text to Image (Tripo only)

```typescript
const taskId = await client.createTask({
  type: TaskType.TEXT_TO_IMAGE,
  prompt: 'a futuristic robot standing in a lab'
});

const result = await client.pollUntilDone(taskId);
console.log('Image URL:', result.result?.generatedImage);
```

### 6. Advanced Image Generation (Tripo only)

```typescript
const taskId = await client.createTask({
  type: TaskType.GENERATE_IMAGE,
  prompt: 'a cartoon cat in T-pose',
  input: 'https://example.com/reference.jpg',  // Optional reference image
  providerOptions: {
    model_version: 'flux.1_kontext_pro',
    t_pose: true
  }
});
```

### 7. Import External Model (Tripo only)

```typescript
// Import a 3D model for post-processing (requires stsUpload for local files)
const provider = new TripoProvider({ stsUpload: true });
const client = new Magi3DClient(provider);

const importTaskId = await client.createTask({
  type: TaskType.IMPORT,
  input: '/path/to/model.glb'
});

const result = await client.pollUntilDone(importTaskId);
// Now use importTaskId for texture, stylize, convert, etc.
```

### 8. Pre-Rig Check (Tripo only)

```typescript
const checkTaskId = await client.createTask({
  type: TaskType.PRE_RIG_CHECK,
  taskId: modelTaskId
});

const check = await client.pollUntilDone(checkTaskId);
console.log('Riggable:', check.result?.riggable);  // true/false
console.log('Rig type:', check.result?.rigType);    // 'biped', 'quadruped', etc.
```

### 9. Add Rigging to Model (Tripo only)

```typescript
const riggedTaskId = await client.createTask({
  type: TaskType.RIG,
  taskId: modelTaskId,
  skeleton: 'biped',
  outFormat: 'fbx'
});
```

### 10. Apply Animation (Tripo only)

```typescript
const animatedTaskId = await client.createTask({
  type: TaskType.ANIMATE,
  taskId: riggedTaskId,   // Must be a RIG task result
  animation: 'preset:walk',
  outFormat: 'glb'
});
```

### 11. Texture Model

```typescript
// Tripo: reference by taskId
const texturedTaskId = await client.createTask({
  type: TaskType.TEXTURE,
  taskId: modelTaskId,
  prompt: 'wooden texture with grain detail',
  enablePBR: true
});

// Hunyuan: reference by modelUrl
const texturedTaskId = await client.createTask({
  type: TaskType.TEXTURE,
  modelUrl: 'https://example.com/model.glb'
});
```

### 12. Mesh Segmentation + Completion (Tripo only)

```typescript
// Step 1: Segment model into parts
const segTaskId = await client.createTask({
  type: TaskType.SEGMENT,
  taskId: modelTaskId
});
await client.pollUntilDone(segTaskId);

// Step 2: Complete/fill specific parts
const completionTaskId = await client.createTask({
  type: TaskType.MESH_COMPLETION,
  taskId: segTaskId,       // Must be a SEGMENT task result
  partNames: ['arm_left']  // Optional: specific parts to complete
});
```

### 13. Reduce Polygon Count

```typescript
// Tripo: use taskId
const decimatedTaskId = await client.createTask({
  type: TaskType.DECIMATE,
  taskId: modelTaskId,
  targetFaceCount: 5000
});

// Hunyuan: use modelUrl
const decimatedTaskId = await client.createTask({
  type: TaskType.DECIMATE,
  modelUrl: 'https://example.com/model.glb',
  providerOptions: {
    FaceLevel: 'low'
  }
});
```

### 14. Stylize Model (Tripo only)

```typescript
const stylizedTaskId = await client.createTask({
  type: TaskType.STYLIZE,
  taskId: modelTaskId,
  style: 'lego'   // 'lego' | 'voxel' | 'voronoi' | 'minecraft'
});
```

### 15. Face Photo to 3D Character (Hunyuan only)

```typescript
const taskId = await client.createTask({
  type: TaskType.PROFILE_TO_3D,
  input: 'https://example.com/face-photo.jpg',  // or base64
  template: 'basketball'  // character template preset
});

const result = await client.pollUntilDone(taskId);
// Available templates: basketball, badminton, pingpong, gymnastics, pilidance,
// tennis, athletics, footballboykicking1, footballboykicking2, guitar,
// footballboy, skateboard, futuresoilder, explorer, beardollgirl,
// bibpantsboy, womansitpose, womanstandpose2, mysteriousprincess, manstandpose2
```

### 16. Convert Format

```typescript
const convertedTaskId = await client.createTask({
  type: TaskType.CONVERT,
  taskId: modelTaskId,
  format: 'fbx',
  providerOptions: {
    export_orientation: '+y',
    fbx_preset: 'mixamo'
  }
});
```

## Task Chaining (Tripo Pipelines)

Tripo tasks chain by passing the completed `taskId` of one task as input to the next. Common pipelines:

### Text to Animated Character

```typescript
// 1. Generate model
const modelId = await client.createTask({
  type: TaskType.TEXT_TO_3D,
  prompt: 'a robot character'
});
await client.pollUntilDone(modelId);

// 2. Check riggability
const checkId = await client.createTask({
  type: TaskType.PRE_RIG_CHECK,
  taskId: modelId
});
const check = await client.pollUntilDone(checkId);

// 3. Rig
if (check.result?.riggable) {
  const rigId = await client.createTask({
    type: TaskType.RIG,
    taskId: modelId,
    skeleton: check.result.rigType || 'biped'
  });
  await client.pollUntilDone(rigId);

  // 4. Animate
  const animId = await client.createTask({
    type: TaskType.ANIMATE,
    taskId: rigId,
    animation: 'preset:walk'
  });
  await client.pollUntilDone(animId);

  // 5. Export as FBX
  const exportId = await client.createTask({
    type: TaskType.CONVERT,
    taskId: animId,
    format: 'fbx'
  });
  const final = await client.pollUntilDone(exportId);
  console.log('Animated FBX:', final.result?.model);
}
```

### Image to Textured Model

```typescript
// 1. Generate from image
const modelId = await client.createTask({
  type: TaskType.IMAGE_TO_3D,
  input: 'https://example.com/chair.jpg'
});
await client.pollUntilDone(modelId);

// 2. Re-texture with prompt
const texId = await client.createTask({
  type: TaskType.TEXTURE,
  taskId: modelId,
  prompt: 'polished walnut wood'
});
await client.pollUntilDone(texId);

// 3. Convert to USDZ for AR
const convertId = await client.createTask({
  type: TaskType.CONVERT,
  taskId: texId,
  format: 'usdz'
});
const final = await client.pollUntilDone(convertId);
console.log('AR-ready model:', final.result?.model);
```

### Text to Image to Model

```typescript
// 1. Generate concept image
const imgId = await client.createTask({
  type: TaskType.TEXT_TO_IMAGE,
  prompt: 'a fantasy sword with glowing runes'
});
const imgResult = await client.pollUntilDone(imgId);

// 2. Use generated image to create 3D model
const modelId = await client.createTask({
  type: TaskType.IMAGE_TO_3D,
  input: imgResult.result!.generatedImage!  // URL from step 1
});
const modelResult = await client.pollUntilDone(modelId);
```

### Hunyuan: Text to Segmented Parts

```typescript
// Hunyuan segment requires FBX input; text-to-3d outputs GLB → convert first

// 1. Generate model
const modelId = await client.createTask({
  type: TaskType.TEXT_TO_3D,
  prompt: 'a bicycle'
});
const modelResult = await client.pollUntilDone(modelId);
const glbUrl = modelResult.result!.model!;

// 2. Convert to FBX (required for segment API)
const convertId = await client.createTask({
  type: TaskType.CONVERT,
  taskId: glbUrl,  // Hunyuan Convert takes model URL as taskId
  format: 'fbx'
});
const convertResult = await client.pollUntilDone(convertId);
const fbxUrl = convertResult.result!.model!;

// 3. Segment into parts
const segId = await client.createTask({
  type: TaskType.SEGMENT,
  modelUrl: fbxUrl
});
const segResult = await client.pollUntilDone(segId);
console.log('Segmented model:', segResult.result?.model);
```

## STS Upload (Tripo only)

By default, Tripo requires publicly accessible URLs for file inputs. Enable `stsUpload: true` to accept local file paths, localhost URLs, and base64 data.

```typescript
const provider = new TripoProvider({
  stsUpload: true   // Enable local file support
});
```

When enabled, the SDK automatically:
- **Images** (jpg, jpeg, png, webp): Uploaded via Direct Upload, returns a `file_token`
- **3D models** (glb, obj, fbx, stl): Uploaded via STS Upload (S3 with temporary credentials)

Accepted input formats with `stsUpload: true`:
- Public URLs: `https://example.com/image.jpg`
- Localhost URLs: `http://localhost:3000/image.jpg`
- File paths: `/path/to/file.jpg` or `./relative/path.glb`
- Base64: `data:image/png;base64,iVBORw0K...`
- `file://` protocol: `file:///path/to/model.glb`

Without `stsUpload`, only public URLs are accepted. Local inputs throw an error.

## React Integration - Complete Example

### Provider Selection with Task Types

```tsx
'use client';
import { useState, useEffect } from 'react';
import {
  useCreateTask,
  useTaskStatus,
  PROVIDERS,
  PROVIDER_TASK_TYPES,
  TaskType,
  TaskStatus,
  ProviderId
} from 'magi-3d/react';

export function Model3DGenerator() {
  // Provider selection
  const [providerId, setProviderId] = useState<ProviderId>(ProviderId.TRIPO);
  const [taskType, setTaskType] = useState<TaskType>(TaskType.TEXT_TO_3D);
  const [prompt, setPrompt] = useState('');

  // Get available task types for selected provider
  const availableTaskTypes = PROVIDER_TASK_TYPES[providerId];

  // Reset task type if not supported by selected provider
  useEffect(() => {
    if (!availableTaskTypes.includes(taskType)) {
      setTaskType(availableTaskTypes[0]);
    }
  }, [providerId, taskType, availableTaskTypes]);

  // Create task hook
  const {
    createTask,
    task,
    taskId,
    isLoading,
    progress,
    error,
    reset
  } = useCreateTask({
    api: '/api/3d',
    onSuccess: (task) => {
      console.log('Model URL:', task.result?.model);
      console.log('Raw API Response:', task.rawResponse);
    },
    onError: (err) => console.error('Generation failed:', err)
  });

  const handleSubmit = async () => {
    await createTask({
      type: taskType,
      prompt,
      providerId // Send to backend for provider selection
    });
  };

  return (
    <div>
      {/* Provider Selection */}
      <label>Provider:</label>
      <select
        value={providerId}
        onChange={(e) => setProviderId(e.target.value as ProviderId)}
        disabled={isLoading}
      >
        {PROVIDERS.map(id => (
          <option key={id} value={id}>{id.toUpperCase()}</option>
        ))}
      </select>

      {/* Task Type Selection */}
      <label>Task Type:</label>
      <select
        value={taskType}
        onChange={(e) => setTaskType(e.target.value as TaskType)}
        disabled={isLoading}
      >
        {availableTaskTypes.map(type => (
          <option key={type} value={type}>{type}</option>
        ))}
      </select>

      {/* Prompt Input */}
      <input
        type="text"
        value={prompt}
        onChange={(e) => setPrompt(e.target.value)}
        placeholder="Enter your prompt..."
        disabled={isLoading}
      />

      {/* Submit Button */}
      <button onClick={handleSubmit} disabled={isLoading || !prompt}>
        {isLoading ? `Generating (${progress}%)` : 'Generate 3D Model'}
      </button>

      {/* Progress Display */}
      {isLoading && (
        <div>
          <progress value={progress} max={100} />
          <span>{task?.progressDetail || 'Processing...'}</span>
        </div>
      )}

      {/* Result Display */}
      {task?.status === TaskStatus.SUCCEEDED && (
        <div>
          <p>Model ready!</p>
          <a href={task.result?.model} download>Download Model</a>
          {task.result?.thumbnail && (
            <img src={task.result.thumbnail} alt="Preview" />
          )}
        </div>
      )}

      {/* Error Display */}
      {error && <p style={{ color: 'red' }}>Error: {error.message}</p>}
    </div>
  );
}
```

### Track Existing Task Status

```tsx
'use client';
import { useEffect } from 'react';
import { useTaskStatus, ProviderId, TaskStatus } from 'magi-3d/react';

interface TaskTrackerProps {
  taskId: string;
  providerId: ProviderId;
}

export function TaskTracker({ taskId, providerId }: TaskTrackerProps) {
  const {
    task,
    progress,
    isPolling,
    error,
    startPolling,
    stopPolling,
    refresh
  } = useTaskStatus({
    api: '/api/3d',
    providerId, // Required - tells backend which provider to query
    pollingInterval: 3000,
    onComplete: (task) => {
      console.log('Task completed:', task.status);
      console.log('Model URL:', task.result?.model);
      console.log('Raw Response:', task.rawResponse);
    },
    onError: (err) => console.error('Polling error:', err)
  });

  // Start polling when component mounts
  useEffect(() => {
    if (taskId) {
      startPolling(taskId);
    }
    return () => stopPolling();
  }, [taskId, startPolling, stopPolling]);

  return (
    <div>
      <h3>Task: {taskId}</h3>
      <p>Provider: {providerId}</p>
      <p>Status: {task?.status || 'Loading...'}</p>
      <p>Progress: {progress}%</p>

      {task?.status === TaskStatus.SUCCEEDED && (
        <a href={task.result?.model} download>Download Model</a>
      )}

      {task?.status === TaskStatus.FAILED && (
        <p style={{ color: 'red' }}>
          Error: {task.error?.message}
        </p>
      )}

      <button onClick={refresh} disabled={isPolling}>
        Refresh
      </button>
    </div>
  );
}
```

### Backend API Routes (Next.js)

```typescript
// app/api/3d/task/route.ts
import { Magi3DClient, TripoProvider, HunyuanProvider, ProviderId } from 'magi-3d/server';

// Create provider instances (uses env vars by default)
const providers = {
  [ProviderId.TRIPO]: new TripoProvider(),
  [ProviderId.HUNYUAN]: new HunyuanProvider({ region: 'ap-guangzhou' })
};

// Create task
export async function POST(req: Request) {
  const { providerId = ProviderId.TRIPO, ...params } = await req.json();

  const provider = providers[providerId as ProviderId];
  if (!provider) {
    return Response.json({ error: 'Invalid provider' }, { status: 400 });
  }

  const client = new Magi3DClient(provider);
  const taskId = await client.createTask(params);
  return Response.json({ taskId });
}

// app/api/3d/task/[id]/route.ts
export async function GET(
  req: Request,
  { params }: { params: { id: string } }
) {
  const { searchParams } = new URL(req.url);
  const providerId = searchParams.get('providerId') as ProviderId;

  const provider = providers[providerId];
  if (!provider) {
    return Response.json({ error: 'Invalid provider' }, { status: 400 });
  }

  const client = new Magi3DClient(provider);
  const task = await client.getTask(params.id);
  return Response.json(task);
}
```

## Provider Options (providerOptions)

Use `providerOptions` for any provider-specific parameter. These are passed directly to the provider API.

### Tripo Generation Options

```typescript
providerOptions: {
  model_version: 'v3.0-20250812',  // or 'v2.5-20250123', 'Turbo-v1.0-20250506'
  pbr: true,
  texture: true,
  texture_quality: 'detailed',     // 'standard' | 'detailed'
  geometry_quality: 'detailed',    // v3.0+ only
  face_limit: 50000,
  quad: false,
  auto_size: true,                 // Real-world scale in meters
  orientation: 'align_image',
  smart_low_poly: false,           // Hand-crafted low-poly topology
  generate_parts: false,           // Segmented model with editable parts
  export_uv: true                  // UV unwrapping during generation
}
```

### Tripo Rigging/Animation Options

```typescript
providerOptions: {
  out_format: 'fbx',              // 'glb' | 'fbx'
  rig_type: 'biped',              // 'biped' | 'quadruped' | 'hexapod' | etc.
  spec: 'tripo',                  // 'mixamo' | 'tripo'
  model_version: 'v2.0-20250506', // Rig model version
  animation: 'preset:walk',       // Single animation preset
  animations: ['preset:walk', 'preset:run'],  // Multiple (max 5)
  bake_animation: true,           // Bake animation into model
  animate_in_place: false          // Fixed position animation
}
```

### Tripo CONVERT Options

```typescript
providerOptions: {
  quad: true,
  face_limit: 10000,
  texture_size: 2048,
  texture_format: 'JPEG',         // JPEG, PNG, BMP, TIFF, WEBP, etc.
  pack_uv: true,
  export_orientation: '+y',        // '+x', '-x', '+y', '-y'
  fbx_preset: 'mixamo',            // 'blender', '3dsmax', 'mixamo'
  with_animation: true,
  bake: true,
  flatten_bottom: false,
  pivot_to_center_bottom: false,
  scale_factor: 1,
  export_vertex_colors: false      // OBJ/GLTF only
}
```

### Tripo Stylize Options

```typescript
providerOptions: {
  block_size: 80                   // Minecraft style grid size (32-128)
}
```

### Hunyuan Generation Options

```typescript
providerOptions: {
  EnablePBR: true,
  FaceCount: 500000,               // 40,000 - 1,500,000
  GenerateType: 'Normal',          // 'Normal', 'LowPoly', 'Geometry', 'Sketch'
  PolygonType: 'triangle',         // 'triangle', 'quadrilateral'
  ResultFormat: 'GLB'              // Rapid only: 'OBJ', 'GLB', 'STL', 'USDZ', 'FBX'
}
```

## StandardTask Response

All providers return this normalized format:

```typescript
interface StandardTask {
  id: string;
  provider: 'tripo' | 'hunyuan';
  type: TaskType;
  status: 'PENDING' | 'PROCESSING' | 'SUCCEEDED' | 'FAILED' | 'TIMEOUT' | 'CANCELED';
  progress: number;           // 0-100
  progressDetail?: string;    // Raw provider status
  result?: {
    model: string;            // Primary model URL - always use this
    modelGlb?: string;        // GLB URL (when format is known)
    modelPbr?: string;        // PBR model URL
    modelBase?: string;       // Base model URL (no texture)
    modelFbx?: string;
    modelObj?: string;
    modelUsdz?: string;
    thumbnail?: string;
    video?: string;
    generatedImage?: string;  // For TEXT_TO_IMAGE, GENERATE_IMAGE tasks
    riggable?: boolean;       // For PRE_RIG_CHECK tasks
    rigType?: string;         // For PRE_RIG_CHECK tasks
  };
  error?: {
    code: string;
    message: string;
    raw: unknown;             // Provider's raw error
  };
  rawResponse?: unknown;      // Full provider API response
  createdAt: number;          // Milliseconds
  finishedAt?: number;        // Milliseconds
}
```

## Error Handling

```typescript
import { TaskError, ApiError } from 'magi-3d/server';

try {
  const result = await client.pollUntilDone(taskId);
} catch (error) {
  if (error instanceof TaskError) {
    // Task failed during generation
    console.log('Task failed:', error.code);
    console.log('Details:', error.task.error?.raw);
  } else if (error instanceof ApiError) {
    // API request failed
    console.log('API error:', error.code, error.httpStatus);
  }
}
```

### Tripo Error Codes

| Tripo Code | SDK Error Code | HTTP | Description |
|------------|----------------|------|-------------|
| 1000 | `SERVER_ERROR` | 500 | Server error |
| 1001 | `FATAL_SERVER_ERROR` | 500 | Fatal server error |
| 2000 | `RATE_LIMIT_EXCEEDED` | 429 | Rate limit hit |
| 2001 | `TASK_NOT_FOUND` | 404 | Invalid task ID |
| 2002 | `UNSUPPORTED_TASK_TYPE` | 400 | Invalid task type |
| 2003 | `INPUT_FILE_EMPTY` | 400 | No input file |
| 2004 | `UNSUPPORTED_FILE_TYPE` | 400 | Bad file format |
| 2006 | `INVALID_ORIGINAL_TASK` | 400 | Bad original task |
| 2007 | `ORIGINAL_TASK_NOT_SUCCESS` | 400 | Original task not done |
| 2008 | `CONTENT_POLICY_VIOLATION` | 400 | Content banned |
| 2010 | `INSUFFICIENT_CREDITS` | 403 | No credits |
| 2014 | `AUDIT_SERVICE_ERROR` | 500 | Content moderation error |
| 2015 | `DEPRECATED_VERSION` | 400 | Version deprecated |
| 2017 | `INVALID_MODEL_VERSION` | 400 | Invalid model version |
| 2018 | `MODEL_TOO_COMPLEX` | 400 | Cannot remesh |
| 2019 | `FILE_NOT_FOUND` | 404 | File reference invalid |

Task status errors: `GENERATION_FAILED`, `CONTENT_POLICY_VIOLATION`, `TASK_EXPIRED`, `TASK_CANCELED`

### Hunyuan Error Codes

| Hunyuan Code | SDK Error Code | Description |
|--------------|----------------|-------------|
| `AuthFailure.SignatureExpire` | `SIGNATURE_EXPIRED` | Signature expired |
| `AuthFailure.SignatureFailure` | `SIGNATURE_FAILURE` | Invalid signature |
| `AuthFailure.SecretIdNotFound` | `SECRET_ID_NOT_FOUND` | Secret ID not found |
| `InvalidParameter` | `INVALID_PARAMETER` | Invalid parameter |
| `MissingParameter` | `MISSING_PARAMETER` | Missing parameter |
| `RequestLimitExceeded` | `RATE_LIMIT_EXCEEDED` | Rate limit exceeded |
| `ResourceNotFound` | `RESOURCE_NOT_FOUND` | Resource not found |
| `FailedOperation.*` | `OPERATION_FAILED` | Operation failed (retry) |
| `InternalError` | `INTERNAL_ERROR` | Internal server error |
| `ServiceUnavailable` | `SERVICE_UNAVAILABLE` | Service unavailable |

Task status errors: `GENERATION_FAILED`, `TASK_CANCELED`

## Provider Comparison

| Feature | Tripo | Hunyuan |
|---------|-------|---------|
| Auth | API Key (TRIPO_API_KEY) | SecretId + SecretKey (HUNYUAN_*) |
| Input | URL (+ local files with stsUpload) | URL or Base64 |
| Task types | 16 | 9 |
| Progress | Granular % | Estimated (0/50/100%) |
| Rigging/Animation | Yes | No |
| Post-processing ref | taskId (chaining) | modelUrl (direct) |
| STS Upload | Yes (opt-in) | No |

---

# PART 2: FOR SDK CONTRIBUTORS

## Project Structure

```
magi-3d-sdk/
├── src/
│   ├── core/
│   │   ├── AbstractProvider.ts   # Base class all providers extend
│   │   └── Magi3DClient.ts       # High-level client with polling
│   ├── providers/
│   │   ├── TripoProvider.ts      # Tripo AI implementation (16 task types)
│   │   └── HunyuanProvider.ts    # Hunyuan implementation (9 task types)
│   ├── react/
│   │   ├── useCreateTask.ts      # Main hook for generation
│   │   ├── useTaskStatus.ts      # Status tracking hook (requires providerId)
│   │   └── usePolling.ts         # Shared polling logic
│   ├── types/
│   │   ├── enums.ts              # TaskType, TaskStatus, ProviderId
│   │   ├── params.ts             # TaskParams union type + options
│   │   ├── result.ts             # StandardTask, TaskArtifacts
│   │   ├── providers.ts          # PROVIDERS, PROVIDER_TASK_TYPES exports
│   │   └── config.ts             # Provider configs (TripoConfig, HunyuanConfig)
│   └── utils/
│       ├── InputUtils.ts         # URL/base64 validation
│       ├── s3-upload.ts          # Minimal AWS SigV4 signer for Tripo STS upload
│       └── TencentCloudSigner.ts # TC3-HMAC-SHA256 for Hunyuan
├── scripts/
│   └── test-*.ts                 # E2E test scripts
└── package.json
```

## Build & Test Commands

```bash
pnpm build          # Build with tsup (ESM + CJS)
pnpm test           # Run unit tests (Vitest)
pnpm typecheck      # TypeScript check
pnpm docs           # Generate TypeDoc

# E2E tests (requires API keys in .env)
pnpm test:tripo     # Quick Tripo test
pnpm test:tripo all # Full Tripo test suite
pnpm test:hunyuan   # Quick Hunyuan test
```

## Core Architecture

### AbstractProvider (Base Class)

All providers extend this class and implement 3 methods:

```typescript
abstract class AbstractProvider<TConfig> {
  protected abstract prepareInput(input: string): Promise<string>;
  protected abstract doCreateTask(params: TaskParams): Promise<string>;
  abstract getTaskStatus(taskId: string): Promise<StandardTask>;
}
```

### Provider Flow

```
createTask(params)
    │
    ├─→ prepareInput(input)     // Validate/transform input
    │
    ├─→ doCreateTask(params)    // Call provider API
    │       │
    │       └─→ buildPayload()  // Build provider-specific request
    │
    └─→ return taskId

getTask(taskId)
    │
    └─→ getTaskStatus(taskId)
            │
            └─→ normalizeResponse()  // Map to StandardTask
```

## Adding a New Task Type

1. **Add enum value** in `src/types/enums.ts`:
```typescript
export enum TaskType {
  // ... existing
  NEW_TASK = 'new_task_value'
}
```

2. **Add params interface** in `src/types/params.ts`:
```typescript
export interface NewTaskParams<T = unknown> extends BaseTaskParams<T> {
  type: TaskType.NEW_TASK;
  taskId: string;
  // ... specific params
}

// Add to TaskParams union
export type TaskParams<T = unknown> =
  | ...
  | NewTaskParams<T>;

// Add type guard
export function isNewTaskParams(p: TaskParams): p is NewTaskParams {
  return p.type === TaskType.NEW_TASK;
}
```

3. **Handle in providers** (`src/providers/TripoProvider.ts`, etc.):
```typescript
// In constructor - register support
this.supportedTaskTypes.add(TaskType.NEW_TASK);

// In buildPayload() - build request
if (isNewTaskParams(params)) {
  return {
    type: 'provider_task_type',
    original_model_task_id: params.taskId,
    ...options
  };
}
```

4. **Update PROVIDER_TASK_TYPES** in `src/types/providers.ts`:
```typescript
export const PROVIDER_TASK_TYPES: Record<ProviderId, readonly TaskType[]> = {
  [ProviderId.TRIPO]: [
    // ... existing
    TaskType.NEW_TASK
  ],
  // ...
};
```

## Adding a New Provider

1. **Create provider file** `src/providers/NewProvider.ts`:

```typescript
import { AbstractProvider } from '../core/AbstractProvider';
import { TaskParams, StandardTask, TaskType, ProviderId } from '../types';
import { InputUtils } from '../utils/InputUtils';

export interface NewProviderConfig {
  apiKey?: string;  // Falls back to NEW_PROVIDER_API_KEY env var
  baseUrl?: string;
}

export class NewProvider extends AbstractProvider<NewProviderConfig> {
  readonly name = 'NewProvider';
  private client: AxiosInstance;

  constructor(config: NewProviderConfig = {}) {
    const apiKey = config.apiKey || process.env.NEW_PROVIDER_API_KEY;
    if (!apiKey) {
      throw new Error('NEW_PROVIDER_API_KEY is required');
    }
    super({ ...config, apiKey });

    // Register supported task types
    this.supportedTaskTypes.add(TaskType.TEXT_TO_3D);
    this.supportedTaskTypes.add(TaskType.IMAGE_TO_3D);

    // Setup HTTP client
    this.client = axios.create({
      baseURL: config.baseUrl ?? 'https://api.newprovider.com',
      headers: { 'Authorization': `Bearer ${apiKey}` }
    });
  }

  protected async prepareInput(input: string): Promise<string> {
    InputUtils.validate(input);
    return input;
  }

  protected async doCreateTask(params: TaskParams): Promise<string> {
    const payload = this.buildPayload(params);
    const response = await this.client.post('/tasks', payload);
    return response.data.task_id;
  }

  async getTaskStatus(taskId: string): Promise<StandardTask> {
    const response = await this.client.get(`/tasks/${taskId}`);
    return this.normalizeResponse(response.data, taskId);
  }

  private buildPayload(params: TaskParams): Record<string, unknown> {
    // Map SDK params to provider API format
  }

  private normalizeResponse(data: any, taskId: string): StandardTask {
    // Map provider response to StandardTask format
    // Include rawResponse for debugging
    return {
      id: taskId,
      provider: ProviderId.NEW_PROVIDER,
      // ...
      rawResponse: data  // Store full API response
    };
  }
}
```

2. **Export from** `src/server/index.ts`:
```typescript
export { NewProvider, type NewProviderConfig } from '../providers/NewProvider';
```

3. **Add to ProviderId enum** in `src/types/enums.ts`:
```typescript
export enum ProviderId {
  TRIPO = 'tripo',
  HUNYUAN = 'hunyuan',
  NEW_PROVIDER = 'new_provider'
}
```

4. **Update PROVIDERS and PROVIDER_TASK_TYPES** in `src/types/providers.ts`:
```typescript
export const PROVIDERS = [ProviderId.TRIPO, ProviderId.HUNYUAN, ProviderId.NEW_PROVIDER] as const;

export const PROVIDER_TASK_TYPES: Record<ProviderId, readonly TaskType[]> = {
  // ... existing
  [ProviderId.NEW_PROVIDER]: [
    TaskType.TEXT_TO_3D,
    TaskType.IMAGE_TO_3D
  ]
};
```

## Key Files Reference

| Task | Files to Modify |
|------|-----------------|
| Add task type | `enums.ts`, `params.ts`, `providers.ts`, `*Provider.ts` |
| Add provider option | `params.ts` (Options interface), `*Provider.ts` (buildPayload) |
| Add result field | `result.ts`, `*Provider.ts` (normalizeResponse) |
| Change polling logic | `Magi3DClient.ts`, `usePolling.ts` |
| Add React hook | `src/react/`, export from `react/index.ts` |
| Add error code | `*Provider.ts` (error mapping) |

## Testing a Provider

Create test in `scripts/test-provider.ts`:

```typescript
import { Magi3DClient, NewProvider, TaskType } from '../src/server';

async function main() {
  const provider = new NewProvider(); // Uses NEW_PROVIDER_API_KEY env var
  const client = new Magi3DClient(provider);

  // Test TEXT_TO_3D
  console.log('Testing TEXT_TO_3D...');
  const taskId = await client.createTask({
    type: TaskType.TEXT_TO_3D,
    prompt: 'a test cube'
  });

  const result = await client.pollUntilDone(taskId, {
    onProgress: (t) => console.log(`Progress: ${t.progress}%`)
  });

  console.log('Primary Model URL:', result.result?.model);
  console.log('Raw Response:', result.rawResponse);
}

main().catch(console.error);
```

## Code Conventions

- Use `async/await` for all async operations
- Prefix private methods with no underscore (use `private` keyword)
- Error codes should be SCREAMING_SNAKE_CASE
- Provider-specific code stays in provider files
- Normalize all responses to StandardTask format
- Always populate `result.model` as primary output
- Include `rawResponse` for debugging
- Keep type guards in `params.ts`
- Export public APIs from index files
- API keys should default to environment variables

## Hunyuan Implementation Notes

- Uses TC3-HMAC-SHA256 signing (see `TencentCloudSigner.ts`)
- Different API actions for different task types (SubmitHunyuanTo3DProJob, etc.)
- Progress is estimated (no granular % from API)
- Supports both URL and Base64 image input
- Post-processing tasks require `modelUrl` (not taskId)
- Format conversion is synchronous (no polling needed)
- Uses HUNYUAN_SECRET_ID and HUNYUAN_SECRET_KEY env vars
- Multiview-to-3D uses the same Pro endpoint (SubmitHunyuanTo3DProJob) with MultiViewImages parameter
- File type in payload (`Type` field) is auto-detected from URL extension via `detectFileType()` helper (supports GLB, FBX, OBJ, STL, USDZ; defaults to GLB)
- **Segment API only accepts FBX files** — chain via Convert first if source is GLB (e.g. text-to-3d → convert fbx → segment)
- Supported task types (9): TEXT_TO_3D, IMAGE_TO_3D, MULTIVIEW_TO_3D, PROFILE_TO_3D, TEXTURE, DECIMATE, UV_UNWRAP, SEGMENT, CONVERT

## Tripo Implementation Notes

- Uses simple API key auth
- Single endpoint for all task types (`POST /v2/openapi/task`)
- Granular progress percentage in response
- URL input by default; local files supported with `stsUpload: true`
- STS upload uses minimal AWS SigV4 signer (no AWS SDK dependency)
- All operations are async (polling required)
- Post-processing tasks use `taskId` (maps to `original_model_task_id` in API)
- Error codes in response `code` field
- Uses TRIPO_API_KEY env var
- Supported task types (16): TEXT_TO_3D, IMAGE_TO_3D, MULTIVIEW_TO_3D, TEXT_TO_IMAGE, GENERATE_IMAGE, TEXTURE, REFINE, PRE_RIG_CHECK, RIG, ANIMATE, SEGMENT, MESH_COMPLETION, DECIMATE, CONVERT, IMPORT, STYLIZE
